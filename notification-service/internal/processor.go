package internal

import (
	"context"
	"fmt"
	"log"
	"strings"
)

type NotificationProcessor struct {
	db          *Database
	llmClient   *LLMClient
	emailClient *EmailClient
}

func NewNotificationProcessor(db *Database) *NotificationProcessor {
	return &NotificationProcessor{
		db:          db,
		llmClient:   NewLLMClient(),
		emailClient: NewEmailClient(),
	}
}

func (np *NotificationProcessor) ProcessNotification(ctx context.Context, event NotificationEvent) error {
	log.Printf("Processing notification: ProductID=%d, EventType=%s", event.ProductID, event.EventType)

	product, err := np.db.GetProductWithUser(event.ProductID)
	if err != nil {
		return fmt.Errorf("failed to get product info: %w", err)
	}

	switch event.EventType {
	case "service_down":
		return np.handleServiceDown(ctx, event, product)
	case "service_up":
		return np.handleServiceUp(ctx, event, product)
	default:
		log.Printf("Unknown event type: %s", event.EventType)
		return nil
	}
}

func (np *NotificationProcessor) handleServiceDown(ctx context.Context, event NotificationEvent, product *Product) error {
	log.Printf("Handling service down for product: %s (ID: %d)", product.Name, product.ID)

	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
	}

	logs, err := np.db.GetLastLogs(product.ID, event.Timestamp, 20)
	if err != nil {
		log.Printf("Warning: Failed to fetch logs for product %d: %v", product.ID, err)
		//we can still send a basic notification
		logs = []Log{}
	}

	log.Printf("Retrieved %d logs for analysis", len(logs))

	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
	}

	log.Printf("Starting LLM analysis for service: %s with %d logs", product.Name, len(logs))
	analysis, err := np.llmClient.AnalyzeLogs(ctx, logs, product.Name, product.Description)
	if err != nil {
		log.Printf("Warning: LLM analysis failed: %v", err)
		analysis = &AnalysisResult{
			Summary: fmt.Sprintf("Service %s has failed. Please check the service status and logs.", product.Name),
			QuickFixes: []QuickFix{
				{
					Title:       "Check Service Status",
					Description: "Verify if the service is running and accessible.",
					Priority:    "high",
				},
				{
					Title:       "Review Recent Logs",
					Description: "Check application and system logs for error messages and patterns.",
					Priority:    "high",
				},
				{
					Title:       "Restart Service",
					Description: "Try restarting the service to resolve temporary issues.",
					Priority:    "medium",
				},
			},
		}
	}

	log.Printf("Analysis complete. Summary: %s", analysis.Summary)
	log.Printf("Generated %d quick fixes for service %s", len(analysis.QuickFixes), product.Name)

	downtime, err := np.db.GetActiveDowntime(product.ID)
	if err != nil {
		log.Printf("Warning: Failed to get active downtime record: %v", err)
		downtime = nil
	}

	if downtime != nil && len(analysis.QuickFixes) > 0 {
		if err := np.db.CreateQuickFixes(downtime.ID, product.ID, analysis.QuickFixes); err != nil {
			log.Printf("Warning: Failed to store quick fixes: %v", err)
		} else {
			log.Printf("Successfully stored %d quick fixes for downtime ID %d", len(analysis.QuickFixes), downtime.ID)
			// Log each quick fix for debugging
			for i, qf := range analysis.QuickFixes {
				log.Printf("Quick Fix %d: [%s] %s - %s", i+1, qf.Priority, qf.Title, qf.Description)
			}
		}
	} else if downtime == nil {
		log.Printf("Warning: No active downtime record found, cannot store quick fixes")
	} else {
		log.Printf("No quick fixes generated by LLM")
	}

	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
	}

	userEmail := event.UserEmail
	if userEmail == "" {
		userEmail = product.User.Email
	}

	if userEmail != "" {
		subject, body := np.emailClient.FormatServiceDownEmail(product.Name, analysis)

		if err := np.emailClient.SendEmail(userEmail, subject, body); err != nil {
			log.Printf("Failed to send email to user %s: %v", product.User.Username, err)
			return fmt.Errorf("failed to send email notification: %w", err)
		}

		log.Printf("Email notification sent to user %s (%s) for service %s", product.User.Username, userEmail, product.Name)
	} else {
		log.Printf("No email configured for user %s, skipping email notification", product.User.Username)
	}

	return nil
}

func (np *NotificationProcessor) handleServiceUp(ctx context.Context, event NotificationEvent, product *Product) error {
	log.Printf("Handling service recovery for product: %s (ID: %d)", product.Name, product.ID)

	// Check if context is cancelled
	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
	}

	userEmail := event.UserEmail
	if userEmail == "" {
		userEmail = product.User.Email
	}

	if userEmail != "" {
		downtimeDuration := "Unknown duration"
		if event.Message != "" {
			//"Service X is back up after 5m30s downtime"
			if strings.Contains(event.Message, "after ") && strings.Contains(event.Message, " downtime") {
				start := strings.Index(event.Message, "after ") + len("after ")
				end := strings.Index(event.Message, " downtime")
				if start < end && end > 0 {
					downtimeDuration = event.Message[start:end]
				}
			}
		}

		subject, body := np.emailClient.FormatServiceUpEmail(product.Name, downtimeDuration)

		if err := np.emailClient.SendEmail(userEmail, subject, body); err != nil {
			log.Printf("Failed to send recovery email to user %s: %v", product.User.Username, err)
			return fmt.Errorf("failed to send recovery email notification: %w", err)
		}

		log.Printf("Recovery email notification sent to user %s (%s) for service %s", product.User.Username, userEmail, product.Name)
	} else {
		log.Printf("No email configured for user %s, skipping recovery email notification", product.User.Username)
	}

	return nil
}

// // TestLLMIntegration tests the LLM integration with sample data
// func (np *NotificationProcessor) TestLLMIntegration(ctx context.Context, productID uint) error {
// 	log.Printf("Testing LLM integration for product ID: %d", productID)

// 	// Get product info
// 	product, err := np.db.GetProductWithUser(productID)
// 	if err != nil {
// 		return fmt.Errorf("failed to get product: %w", err)
// 	}

// 	// Get recent logs
// 	logs, err := np.db.GetLastLogs(productID, time.Now(), 10)
// 	if err != nil {
// 		log.Printf("Warning: Failed to get logs, using sample logs: %v", err)
// 		// Create sample logs for testing
// 		logs = []Log{
// 			{LogData: "ERROR: Database connection timeout after 30s", Timestamp: time.Now().Add(-5 * time.Minute)},
// 			{LogData: "WARN: High memory usage detected: 85%", Timestamp: time.Now().Add(-4 * time.Minute)},
// 			{LogData: "ERROR: Failed to connect to Redis: connection refused", Timestamp: time.Now().Add(-3 * time.Minute)},
// 		}
// 	}

// 	// Test LLM analysis
// 	analysis, err := np.llmClient.AnalyzeLogs(ctx, logs, product.Name, product.Description)
// 	if err != nil {
// 		return fmt.Errorf("LLM analysis failed: %w", err)
// 	}

// 	log.Printf("LLM Test Results:")
// 	log.Printf("Summary: %s", analysis.Summary)
// 	log.Printf("Quick Fixes (%d):", len(analysis.QuickFixes))
// 	for i, qf := range analysis.QuickFixes {
// 		log.Printf("  %d. [%s] %s: %s", i+1, qf.Priority, qf.Title, qf.Description)
// 	}

// 	return nil
// }

func (np *NotificationProcessor) Close() error {
	return nil
}
