package internal

import (
	"fmt"
	"log"
	"net/smtp"
	"os"
	"strings"
)

type EmailClient struct {
	smtpHost     string
	smtpPort     string
	fromEmail    string
	fromPassword string
	fromName     string
}

func NewEmailClient() *EmailClient {
	smtpHost := os.Getenv("SMTP_HOST")
	smtpPort := os.Getenv("SMTP_PORT")
	fromEmail := os.Getenv("SMTP_FROM_EMAIL")
	fromPassword := os.Getenv("SMTP_FROM_PASSWORD")
	fromName := os.Getenv("SMTP_FROM_NAME")

	if smtpHost == "" {
		smtpHost = "smtp.gmail.com"
	}
	if smtpPort == "" {
		smtpPort = "587"
	}
	if fromName == "" {
		fromName = "OpsBuddy Monitoring"
	}

	if fromEmail == "" || fromPassword == "" {
		log.Println("Warning: SMTP credentials not configured. Email notifications will be mocked.")
		return &EmailClient{
			smtpHost: smtpHost,
			smtpPort: smtpPort,
			fromName: fromName,
		}
	}

	return &EmailClient{
		smtpHost:     smtpHost,
		smtpPort:     smtpPort,
		fromEmail:    fromEmail,
		fromPassword: fromPassword,
		fromName:     fromName,
	}
}

func (ec *EmailClient) SendEmail(toEmail, subject, body string) error {
	if ec.fromEmail == "" || ec.fromPassword == "" {
		log.Printf("MOCK EMAIL to %s: Subject: %s\nBody: %s", toEmail, subject, body)
		return nil
	}

	auth := smtp.PlainAuth("", ec.fromEmail, ec.fromPassword, ec.smtpHost)

	msg := []byte(fmt.Sprintf("To: %s\r\n"+
		"From: %s <%s>\r\n"+
		"Subject: %s\r\n"+
		"Content-Type: text/plain; charset=UTF-8\r\n"+
		"\r\n"+
		"%s\r\n", toEmail, ec.fromName, ec.fromEmail, subject, body))

	err := smtp.SendMail(ec.smtpHost+":"+ec.smtpPort, auth, ec.fromEmail, []string{toEmail}, msg)
	if err != nil {
		return fmt.Errorf("failed to send email: %w", err)
	}

	log.Printf("Email sent successfully to %s", toEmail)
	return nil
}

func (ec *EmailClient) FormatServiceDownEmail(serviceName string, analysis *AnalysisResult) (string, string) {
	subject := fmt.Sprintf("ðŸš¨ ALERT: %s is DOWN", serviceName)

	var body strings.Builder
	body.WriteString(fmt.Sprintf("Service Alert: %s is currently DOWN\n\n", serviceName))
	body.WriteString(fmt.Sprintf("Issue Analysis: %s\n\n", analysis.Summary))
	body.WriteString("Recommended Quick Fixes:\n\n")

	for i, fix := range analysis.QuickFixes {
		priority := ""
		switch fix.Priority {
		case "high":
			priority = "[HIGH PRIORITY]"
		case "medium":
			priority = "[MEDIUM PRIORITY]"
		case "low":
			priority = "[LOW PRIORITY]"
		}

		body.WriteString(fmt.Sprintf("%d. %s %s\n   %s\n\n",
			i+1, priority, fix.Title, fix.Description))
	}

	body.WriteString("---\n")
	body.WriteString("This alert was generated by OpsBuddy Monitoring System\n")
	body.WriteString("Please take immediate action to resolve the issue.")

	return subject, body.String()
}

func (ec *EmailClient) FormatServiceUpEmail(serviceName string, downtimeDuration string) (string, string) {
	subject := fmt.Sprintf("âœ… RESOLVED: %s is back UP", serviceName)

	body := fmt.Sprintf("Service Recovery: %s is now operational\n\n"+
		"Total Downtime: %s\n\n"+
		"The service has been restored and is functioning normally.\n\n"+
		"---\n"+
		"This recovery notification was generated by OpsBuddy Monitoring System",
		serviceName, downtimeDuration)

	return subject, body
}
